# AUTOGENERATED! DO NOT EDIT! File to edit: 89_Simple_pendulum_simulation.ipynb (unless otherwise specified).

__all__ = ['PendulumParameters', 'Load', 'Pendulum', 'PendulumDrawer', 'AnimatePendulum', 'wrap', 'DCMotorParams',
           'DCMotor', 'MotorController', 'AnimateControlledPendulum']

# Cell
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import pandas as pd
from collections import defaultdict
from time import time as systime

# Cell
class PendulumParameters:
    _g = 9.81          # acceleration due to gravity (m/s^2)

    def __init__(self):
        self._rod_length = 0.43 # m
        self._rod_mass = 0.095  # kg
        self._bob_mass = 0.380  # kg
        self._b = 0.003         # estimate of viscous friction coefficient (N-m-s)
        self._update_params()

    def _update_params(self):
        self._I0 = self._rod_mass*self._rod_length**2/3 + self._bob_mass*self._rod_length**2 # estimate of pendulum mass moment of inertia (kg-m^2) - e.g. 0.079
        self._l_G = (self._bob_mass*self._rod_length+0.5*self._rod_mass*self._rod_length)/(self._bob_mass+self._rod_mass);   # location of pendulum mass center (m)

    @property
    def b(self):
        return self._b

    @b.setter
    def b(self, v):
        self._b = v
        self._update_params()

    @property
    def rod_length(self):
        return self._rod_length

    @rod_length.setter
    def rod_length(self, l):
        self._rod_length = l
        self._update_params()

    @property
    def rod_mass(self):
        return self._rod_mass

    @rod_mass.setter
    def rod_mass(self, m):
        self._rod_mass = m
        self._update_params()

    @property
    def bob_mass(self):
        return self._bob_mass

    @rod_mass.setter
    def bob_mass(self, m):
        self._bob_mass = m
        self._update_params()


class Load():
    def position(self):
        raise Exception("Not implemented.")
    def speed(self):
        raise Exception("Not implemented")
    def moment_of_inertia(self):
        raise Exception("Not implemented.")

class Pendulum(Load):
    def __init__(self, theta_0, theta_dot_0, params):
        self._x_1 = theta_0     # theta (position - (rad))
        self._x_2 = theta_dot_0 # theta_dot (velocity - (rad/s))
        self._params = params
        self._time_elapsed = 0

    def step(self, dt, u=0):
        self._x_1 = self._x_1 + dt*self._x_2
        self._x_2 = self._x_2 + \
            dt*1/self._params._I0*(+u \
                                   -(self._params._bob_mass+self._params._rod_mass)*PendulumParameters._g*self._params._l_G*np.sin(self._x_1) \
                                   - self._params._b*self._x_2)
        self._time_elapsed += dt

    def rod_position_at(self, angle_deg):
        rod_end_1 = 0, 0
        rod_end_2 = rod_end_1[0]+ self._params._rod_length*np.sin(np.radians(angle_deg)), \
                    rod_end_1[1]- self._params._rod_length*np.cos(np.radians(angle_deg)),
        return rod_end_1, rod_end_2

    def rod_position(self):
        return self.rod_position_at(self.sense_theta_deg())
#         rod_end_1 = 0, 0
#         rod_end_2 = rod_end_1[0]+ self._params._rod_length*np.sin(np.radians(self.sense_theta_deg())), \
#                     rod_end_1[1]- self._params._rod_length*np.cos(np.radians(self.sense_theta_deg())),
#         return rod_end_1, rod_end_2

    def position(self):
        return self._x_1 # we measure theta (rad)

    def speed(self):
        return self._x_2 # we need this to connect to a motor

    def sense_theta_deg(self):
        return np.degrees(self._x_1) # we measure theta (deg)

    def moment_of_inertia(self):
        return self._params._I0

# Cell
class PendulumDrawer():
    def __init__(self, pendulum):
        self._pendulum = pendulum
        self._rod_points = []
        self._bob_points = []

    def draw(self, ax):
        rod_end_1, rod_end_2 = self._pendulum.rod_position()

        assert abs(self._pendulum._params._rod_length - np.linalg.norm(rod_end_2)) < 0.01, "rod length is variable: , {} != {}".format(self._pendulum._params._rod_length, np.linalg.norm(rod_end_2))

        if type(pendulum_drawer._bob_points) != matplotlib.lines.Line2D: #len(self._bob_points) == 0:
            self._rod_points, = ax.plot([rod_end_1[0], rod_end_2[0]], [rod_end_1[1], rod_end_2[1]], linewidth=3, color='black')
            self._bob_points, = ax.plot(rod_end_2[0], rod_end_2[1], marker='.', markersize=40, color='red')
        else:
            self._rod_points.set_xdata([rod_end_1[0], rod_end_2[0]])
            self._rod_points.set_ydata([rod_end_1[1], rod_end_2[1]])
            self._bob_points.set_xdata(rod_end_2[0])
            self._bob_points.set_ydata(rod_end_2[1])


    def animated_draw(self, ax):
        rod_end_1, rod_end_2 = self._pendulum.rod_position()
        assert abs(self._pendulum._params._rod_length - np.linalg.norm(rod_end_2)) < 0.01, "rod length is variable: , {} != {}".format(self._pendulum._params._rod_length, np.linalg.norm(rod_end_2))

        if type(pendulum_drawer._bob_points) != matplotlib.lines.Line2D: #len(self._bob_points) == 0:
            self._rod_points = ax.plot([rod_end_1[0], rod_end_2[0]], [rod_end_1[1], rod_end_2[1]], linewidth=3, color='black', animated=True)
            self._bob_points, = ax.plot(rod_end_2[0], rod_end_2[1], marker='.', markersize=40, color='red', animated=True)
        else:
            self._rod_points.set_xdata([rod_end_1[0], rod_end_2[0]])
            self._rod_points.set_ydata([rod_end_1[1], rod_end_2[1]])
            self._bob_points.set_xdata(rod_end_2[0])
            self._bob_points.set_ydata(rod_end_2[1])
        return [self._rod_points, self._bob_points]

# Cell
class AnimatePendulum():
    """See also: https://jakevdp.github.io/blog/2012/08/18/matplotlib-animation-tutorial/"""
    def __init__(self, pendulum, t0, tf, dt):
        self._pendulum = pendulum
        self._t0, self._tf, self._dt = t0, tf, dt
        self._data = defaultdict(list)

        self._fig = plt.figure()
        self._ax = self._fig.add_subplot(111, aspect='equal', autoscale_on=False,
                                 xlim=(-.5, .5), ylim=(-.5, 0))
        self._ax.grid()
        self._line, = self._ax.plot([], [], 'o-', lw=2)

        self._title = self._ax.text(0.5, 1.05, "", #bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},
                    transform=self._ax.transAxes, ha="center")

    def animate_init(self):
        """Initialize animation.
           Plot the background of each frame. """
        self._line.set_data([], [])
        return self._line

    def simulate(self, u):
        for t in np.arange(start=t0, stop=tf, step=dt):
            self._pendulum.step(dt, u)
            self._data['angles'].append(self._pendulum.sense_theta_deg())
            self._data['time'].append(t)

    def animate(self, i):
        """Animation function.
           This is called sequentially to perform animation step"""
        rod_end_1, rod_end_2 = self._pendulum.rod_position_at(self._data['angles'][i])
        self._line.set_data([rod_end_1[0], rod_end_2[0]], [rod_end_1[1], rod_end_2[1]])
        self._title.set_text(u"t = {:.1f}s".format(self._data['time'][i]))
        return self._line, self._title

    def animate_and_simulate(self, i):
        """Animation function.
           This is called sequentially to perform animation step"""
        self._pendulum.step(self.dt, u=0)
        rod_end_1, rod_end_2 = self._pendulum.rod_position()
        self._line.set_data([rod_end_1[0], rod_end_2[0]], [rod_end_1[1], rod_end_2[1]])
        return line, time_text

    def start_animation(self):
        # choose the interval based on dt and the time to animate one step
        t_start = systime()
        self.animate(0)
        t_end = systime()
        interval = 1000 * self._dt - (t_end - t_start)
        n_frames = int((self._tf-self._t0)/self._dt)

        # call the animator. blit=True means only re-draw the parts that have changed.
        anim = animation.FuncAnimation(self._fig, self.animate, init_func=self.animate_init,
                                       frames=n_frames, interval=interval, blit=True,
                                       repeat_delay=10000, repeat=True);
        plt.close()
        return anim

# Cell
def wrap(angle):
    "Wraps an angle between -pi and pi."
    return (angle + np.pi) % (2 * np.pi) - np.pi

# Cell
class DCMotorParams():
    def __init__(self, J=0.01, b=0.1, K=0.01, R=1, L=0.5):
            #     (J)     moment of inertia of the rotor     0.01 kg.m^2
            #     (b)     motor viscous friction constant    0.1 N.m.s
            #     (Ke)    electromotive force constant       0.01 V/rad/sec
            #     (Kt)    motor torque constant              0.01 N.m/Amp
            #     (R)     electric resistance                1 Ohm
            #     (L)     electric inductance                0.5 H
        self.J = J
        self.b = b
        self.K = K
        self.R = R
        self.L = L

class DCMotor():
    def __init__(self, x0, params):
        self._params  = params

        self._x0 = x0
        self._x = x0
        self._J_load = 0
        self._update_motor_matrix()

        self._load = False

    def _update_motor_matrix(self):
        # state variables are: position (theta), rotation speed (w, or theta_dot) and current (i)
        self._A = np.array([
            [0, 1, 0],
            [0, -self._params.b/(self._params.J+self._J_load),  self._params.K/(self._params.J+self._J_load)],
            [0, -self._params.K/self._params.L,  -self._params.R/self._params.L]
            ])
        self._B = np.array([[0],[0],[1/self._params.L]])
        self._C = np.array([
            [1, 0, 0], # position
            [0, 1, 0]  # velocity
        ])
        self._D = 0;

    def step(self, dt, u):
        self._x = self._x + dt*(self._A@self._x + self._B*u)

        # wrap theta to stay between -pi and pi
        self._x[0] = wrap(self._x[0])

    def reset(self):
        self._x = self._x0

    def set_load_parameters(self, J_load):
        self._params.J += J_load
        self.update_motor_matrix()

    def connect_to(self, load):
        self._load = load
        self._params.J = load.moment_of_inertia()
        self._update_motor_matrix()

    def _output_equation(self):
        return self._C@self._x

    def measure(self):
        # We need to move this function out of the DCMotor class.
        return np.array([[self._load.position()], [self._load.speed()]]) \
                        if self._load else self._output_equation()



    def get_motor_torque(self):
        """the motor torque is proportional to only the armature current `i` by a constant factor `K`: T=K*i"""
        return self._params.K*self._x[1,0]

# Cell
class MotorController():
    def __init__(self, Kp, Kd, Ki, motor):
        self.motor = motor
        self.Kp = Kp
        self.Kd = Kd
        self.Ki = Ki

        self.y_history = np.array([[0],[0]]) # initialise to 0. This is only here to have the correct size. Alternative: y = np.empty((2,1))
        self.error_history = np.array([[0]])
        self.elapsed_time = np.array([[0]])
        self.motor_torque = np.array([[0]])

        self._error_old = 0
        self._error_I  = 0


    def run(self, dt, ref_position_rad, y):
#            y = self.motor.measure()
            position, velocity = y[0], y[1]
            # apply controller
            error = ref_position_rad - position
            error_dot = (error - self._error_old)/dt
            self._error_I   += error*dt
            self._error_old = error
            # controller
            u = self.Kp*error + self.Kd*error_dot + self.Ki*self._error_I


            self.motor.step(dt, u)

            # save the last measurements
            self.y_history = np.append(self.y_history, y, axis=1)
            self.error_history = np.append(self.error_history, [error], axis=1)
            self.elapsed_time = np.append(self.elapsed_time, [[self.elapsed_time[0][-1]+dt]], axis=1)
            self.motor_torque = np.append(self.motor_torque, [[self.motor.get_motor_torque()]], axis=1)

    def get_results(self):
        # when we return remove the first item which was there only to have the correct size
        y_history = np.delete(self.y_history, 0, axis=1)
        error_history = np.delete(self.error_history, 0, axis=1)
        elapsed_time = np.delete(self.elapsed_time, 1, axis=1)
        motor_torque = np.delete(self.motor_torque, 0, axis=1)

        position = y_history[0,:]
        velocity = y_history[1,:]
        error = error_history[0,:]
        torque = motor_torque[0,:]

        return position, velocity, error, torque

# Cell
class AnimateControlledPendulum():
    """See also: https://jakevdp.github.io/blog/2012/08/18/matplotlib-animation-tutorial/"""
    def __init__(self, pendulum, motor, controller, t0, tf, dt):
        self._pendulum = pendulum
        self._motor = motor
        self._controller = controller

        # connect the motor to the pendulum
        motor.connect_to(pendulum)

        self._t0, self._tf, self._dt = t0, tf, dt
        self._data = defaultdict(list)

        self._fig = plt.figure()
        self._ax = self._fig.add_subplot(111, aspect='equal', autoscale_on=False,
                                 xlim=(-.5, .5), ylim=(-.5, 0))
        self._ax.grid()
        self._line, = self._ax.plot([], [], 'o-', lw=2)

        self._title = self._ax.text(0.5, 1.05, "", #bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},
                    transform=self._ax.transAxes, ha="center")

    def animate_init(self):
        """Initialize animation.
           Plot the background of each frame. """
        self._line.set_data([], [])
        return self._line

    def simulate(self, angle_ref, controller_flag=True):
        for t in np.arange(start=self._t0, stop=self._tf, step=self._dt):
            self._controller.run(self._dt,
                             ref_position_rad=np.radians(angle_ref),
                             y = np.array([[np.radians(self._pendulum.sense_theta_deg())], [self._pendulum.speed()]]))
            self._pendulum.step(self._dt, u=self._controller.motor.get_motor_torque() if controller_flag else 0)
            self._data['angles'].append(self._pendulum.sense_theta_deg())
            self._data['time'].append(t)

    def animate(self, i):
        """Animation function.
           This is called sequentially to perform animation step"""
        rod_end_1, rod_end_2 = self._pendulum.rod_position_at(self._data['angles'][i])
        self._line.set_data([rod_end_1[0], rod_end_2[0]], [rod_end_1[1], rod_end_2[1]])
        self._title.set_text(u"t = {:.1f}s".format(self._data['time'][i]))
        return self._line, self._title

    def animate_and_simulate(self, i):
        """Animation function.
           This is called sequentially to perform animation step"""
        self._pendulum.step(self._dt, u=0)
        rod_end_1, rod_end_2 = self._pendulum.rod_position()
        self._line.set_data([rod_end_1[0], rod_end_2[0]], [rod_end_1[1], rod_end_2[1]])
        return line, time_text

    def start_animation(self):
        # choose the interval based on dt and the time to animate one step
        t_start = systime()
        self.animate(0)
        t_end = systime()
        interval = 1000 * self._dt - (t_end - t_start)
        n_frames = int((self._tf-self._t0)/self._dt)

        # call the animator. blit=True means only re-draw the parts that have changed.
        anim = animation.FuncAnimation(self._fig, self.animate, init_func=self.animate_init,
                                       frames=n_frames, interval=interval, blit=True,
                                       repeat_delay=10000, repeat=True);
        plt.close()
        return anim