# AUTOGENERATED! DO NOT EDIT! File to edit: 02_Intro_to_control_theory.ipynb (unless otherwise specified).

__all__ = ['Car', 'LinearCar', 'step', 'delta', 'ramp_as_impulses']

# Cell
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# Cell
class Car:
    _g = 9.8 # Gravity

    def __init__(self, x0, params):
        self._x_1 = x0[0] # position (along the road)
        self._x_2 = x0[1] # velocity (along the road)
        self._m, self._alpha, self._beta, self._gamma = params

    def step(self, dt, u, theta):
        self.theta = theta
        self._x_1 = self._x_1 + dt*self._x_2
        self._x_2 = self._x_2 + dt*(-self._alpha/self._m*abs(self._x_2)*self._x_2 - \
                                    self._beta/self._m*self._x_2 + self._gamma/self._m*u - \
                                    Car._g*np.sin(theta))

    def speedometer(self):
        v = self._x_2
        return (v,)

    # Utility function to simplify plotting
    def sensor_i(self):
        # Rotation matrix to get back to the main frame.
        R = np.array(((np.cos(theta), -np.sin(theta)), (np.sin(theta), np.cos(theta))))
        x_i, y_i = R.dot(np.array([[self._x_1],[0]]))
        v = self._x_2
        return (x_i, y_i, v)

# Cell
class LinearCar:
    _g = 9.8

    def __init__(self, x0, params):
        self._x_1 = x0[0] # position (along the road)
        self._x_2 = x0[1] # velocity
        self._m, self._alpha, self._beta, self._gamma = params

    def step(self, dt, u, theta):
        # u: gas pedal
        # theta: slope of the road
        self._theta = theta
        A = np.array([[0, 1], [0, -self._beta/self._m]])
        B = np.array([[0, 0], [self._gamma/self._m, -LinearCar._g]])

        x = np.array([[self._x_1],[self._x_2]])
        U = np.array([[u],[theta]])

        self._x_1 = (self._x_1 + dt*(A[0,np.newaxis,:].dot(x) + B[0,np.newaxis,:].dot(U))).item()
        self._x_2 = (self._x_2 + dt*(A[1,np.newaxis,:].dot(x) + B[1,np.newaxis,:].dot(U))).item()

    def speedometer(self):
        v = self._x_2
        return (v,)

    # Utility function to simplify plotting
    def sensor_i(self):
        # Rotation matrix to get back to the inertial frame..
        R = np.array(((np.cos(self._theta), -np.sin(self._theta)),
                      (np.sin(self._theta), np.cos(self._theta))))
        x_i, y_i = R.dot(np.array([[self._x_1],[0]]))
        v = self._x_2
        return (x_i, y_i, v)

# Cell
def step(t, step_time=0):
    """Heaviside step function"""
    return 1 * (t >= step_time)

def delta(t, delta_t=0, eps=None): # Impulse
    if np.isscalar(t) and eps is None:
        raise Exception('eps must be defined for scalar values.')
    if eps is None and len(t) > 1:
        _eps=t[1]-t[0]
    else:
        _eps = eps
    return 1/_eps*(step(t, delta_t-_eps/2)-step(t, delta_t+_eps/2))

# Cell
def ramp_as_impulses(t, time_vector):
    u = t*delta(time_vector, delta_t=t, eps=.01)
    return u